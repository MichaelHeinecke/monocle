// Copyright (C) 2021 Monocle authors
// SPDX-License-Identifier: AGPL-3.0-or-later

// Generated by monocle-codegen. DO NOT EDIT!

type axiosRequestHeaders = {"Authorization": string}
type axiosRequestConfig = {headers: axiosRequestHeaders}
type axiosResponse<'data> = {data: 'data}
type axios<'data> = Js.Promise.t<axiosResponse<'data>>
let serverUrl = %raw(`
  (window.API_URL !== '__API_URL__' ? window.API_URL : process.env.REACT_APP_API_URL || '')
`)

module Login = {
  @module("axios")
  external loginValidationRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let loginValidation = (
    request: LoginTypes.login_validation_request,
    token: option<string>,
  ): axios<LoginTypes.login_validation_response> =>
    loginValidationRaw(
      serverUrl ++ "/api/2/login/username/validate",
      request->LoginBs.encode_login_validation_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->LoginBs.decode_login_validation_response}->Js.Promise.resolve
    )
}

module Auth = {
  @module("axios")
  external getMagicJwtRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let getMagicJwt = (request: AuthTypes.get_magic_jwt_request, token: option<string>): axios<
    AuthTypes.get_magic_jwt_response,
  > =>
    getMagicJwtRaw(
      serverUrl ++ "/api/2/auth/get",
      request->AuthBs.encode_get_magic_jwt_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->AuthBs.decode_get_magic_jwt_response}->Js.Promise.resolve
    )
  @module("axios")
  external whoAmiRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let whoAmi = (request: AuthTypes.who_ami_request, token: option<string>): axios<
    AuthTypes.who_ami_response,
  > =>
    whoAmiRaw(
      serverUrl ++ "/api/2/auth/whoami",
      request->AuthBs.encode_who_ami_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->AuthBs.decode_who_ami_response}->Js.Promise.resolve
    )
}

module Config = {
  @module("axios")
  external getWorkspacesRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let getWorkspaces = (request: ConfigTypes.get_workspaces_request, token: option<string>): axios<
    ConfigTypes.get_workspaces_response,
  > =>
    getWorkspacesRaw(
      serverUrl ++ "/api/2/get_workspaces",
      request->ConfigBs.encode_get_workspaces_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->ConfigBs.decode_get_workspaces_response}->Js.Promise.resolve
    )
  @module("axios")
  external getProjectsRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let getProjects = (request: ConfigTypes.get_projects_request, token: option<string>): axios<
    ConfigTypes.get_projects_response,
  > =>
    getProjectsRaw(
      serverUrl ++ "/api/2/get_projects",
      request->ConfigBs.encode_get_projects_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->ConfigBs.decode_get_projects_response}->Js.Promise.resolve
    )
  @module("axios")
  external getGroupsRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let getGroups = (request: ConfigTypes.get_groups_request, token: option<string>): axios<
    ConfigTypes.get_groups_response,
  > =>
    getGroupsRaw(
      serverUrl ++ "/api/2/get_groups",
      request->ConfigBs.encode_get_groups_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->ConfigBs.decode_get_groups_response}->Js.Promise.resolve
    )
  @module("axios")
  external getGroupMembersRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let getGroupMembers = (
    request: ConfigTypes.get_group_members_request,
    token: option<string>,
  ): axios<ConfigTypes.get_group_members_response> =>
    getGroupMembersRaw(
      serverUrl ++ "/api/2/get_group_members",
      request->ConfigBs.encode_get_group_members_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->ConfigBs.decode_get_group_members_response}->Js.Promise.resolve
    )
  @module("axios")
  external getAboutRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let getAbout = (request: ConfigTypes.get_about_request, token: option<string>): axios<
    ConfigTypes.get_about_response,
  > =>
    getAboutRaw(
      serverUrl ++ "/api/2/about",
      request->ConfigBs.encode_get_about_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->ConfigBs.decode_get_about_response}->Js.Promise.resolve
    )
}

module Search = {
  @module("axios")
  external suggestionsRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let suggestions = (request: SearchTypes.suggestions_request, token: option<string>): axios<
    SearchTypes.suggestions_response,
  > =>
    suggestionsRaw(
      serverUrl ++ "/api/2/suggestions",
      request->SearchBs.encode_suggestions_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->SearchBs.decode_suggestions_response}->Js.Promise.resolve
    )
  @module("axios")
  external fieldsRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let fields = (request: SearchTypes.fields_request, token: option<string>): axios<
    SearchTypes.fields_response,
  > =>
    fieldsRaw(
      serverUrl ++ "/api/2/search/fields",
      request->SearchBs.encode_fields_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->SearchBs.decode_fields_response}->Js.Promise.resolve
    )
  @module("axios")
  external checkRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let check = (request: SearchTypes.check_request, token: option<string>): axios<
    SearchTypes.check_response,
  > =>
    checkRaw(
      serverUrl ++ "/api/2/search/check",
      request->SearchBs.encode_check_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->SearchBs.decode_check_response}->Js.Promise.resolve
    )
  @module("axios")
  external queryRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let query = (request: SearchTypes.query_request, token: option<string>): axios<
    SearchTypes.query_response,
  > =>
    queryRaw(
      serverUrl ++ "/api/2/search/query",
      request->SearchBs.encode_query_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->SearchBs.decode_query_response}->Js.Promise.resolve
    )
  @module("axios")
  external authorRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let author = (request: SearchTypes.author_request, token: option<string>): axios<
    SearchTypes.author_response,
  > =>
    authorRaw(
      serverUrl ++ "/api/2/search/author",
      request->SearchBs.encode_author_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->SearchBs.decode_author_response}->Js.Promise.resolve
    )
}

module Metric = {
  @module("axios")
  external listRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let list = (request: MetricTypes.list_request, token: option<string>): axios<
    MetricTypes.list_response,
  > =>
    listRaw(
      serverUrl ++ "/api/2/metric/list",
      request->MetricBs.encode_list_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->MetricBs.decode_list_response}->Js.Promise.resolve
    )
  @module("axios")
  external getRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let get = (request: MetricTypes.get_request, token: option<string>): axios<
    MetricTypes.get_response,
  > =>
    getRaw(
      serverUrl ++ "/api/2/metric/get",
      request->MetricBs.encode_get_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->MetricBs.decode_get_response}->Js.Promise.resolve
    )
  @module("axios")
  external infoRaw: (string, 'data, option<axiosRequestConfig>) => axios<'b> = "post"

  let info = (request: MetricTypes.info_request, token: option<string>): axios<
    MetricTypes.info_response,
  > =>
    infoRaw(
      serverUrl ++ "/api/2/metric/info",
      request->MetricBs.encode_info_request,
      token->Belt.Option.flatMap(jwt => {headers: {"Authorization": "Bearer " ++ jwt}}->Some),
    ) |> Js.Promise.then_(resp =>
      {data: resp.data->MetricBs.decode_info_response}->Js.Promise.resolve
    )
}

module Crawler = {

}
